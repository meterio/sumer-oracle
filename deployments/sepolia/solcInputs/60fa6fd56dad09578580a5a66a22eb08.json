{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/accessControl/AccessControlledV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport \"./IAccessControlManagerV8.sol\";\n\n/**\n * @title AccessControlledV8\n * @author Venus\n * @notice This contract is helper between access control manager and actual contract. This contract further inherited by other contract (using solidity 0.8.13)\n * to integrate access controlled mechanism. It provides initialise methods and verifying access methods.\n */\nabstract contract AccessControlledV8 is Ownable2Step {\n    /// @notice Access control manager contract\n    IAccessControlManagerV8 private _accessControlManager;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n\n    /// @notice Emitted when access control manager contract address is changed\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\n\n    /// @notice Thrown when the action is prohibited by AccessControlManager\n    error Unauthorized(address sender, address calledContract, string methodSignature);\n\n    /**\n     * @notice Sets the address of AccessControlManager\n     * @dev Admin function to set address of AccessControlManager\n     * @param accessControlManager_ The new address of the AccessControlManager\n     * @custom:event Emits NewAccessControlManager event\n     * @custom:access Only Governance\n     */\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\n        _setAccessControlManager(accessControlManager_);\n    }\n\n    /**\n     * @notice Returns the address of the access control manager contract\n     */\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\n        return _accessControlManager;\n    }\n\n    /**\n     * @dev Internal function to set address of AccessControlManager\n     * @param accessControlManager_ The new address of the AccessControlManager\n     */\n    function _setAccessControlManager(address accessControlManager_) internal {\n        require(address(accessControlManager_) != address(0), \"invalid acess control manager address\");\n        address oldAccessControlManager = address(_accessControlManager);\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\n    }\n\n    /**\n     * @notice Reverts if the call is not allowed by AccessControlManager\n     * @param signature Method signature\n     */\n    function _checkAccessAllowed(string memory signature) internal view {\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\n\n        if (!isAllowedToCall) {\n            revert Unauthorized(msg.sender, address(this), signature);\n        }\n    }\n}\n"
    },
    "contracts/accessControl/IAccessControlManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface OracleInterface {\n    function getPrice(address asset) external view returns (uint256);\n}\n\ninterface ResilientOracleInterface is OracleInterface {\n    function updatePrice(address vToken) external;\n\n    function updateAssetPrice(address asset) external;\n\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\n}\n\ninterface TwapInterface is OracleInterface {\n    function updateTwap(address asset) external returns (uint256);\n}\n\ninterface BoundValidatorInterface {\n    function validatePriceWithAnchorPrice(\n        address asset,\n        uint256 reporterPrice,\n        uint256 anchorPrice\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/VBep20Interface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface VBep20Interface is IERC20Metadata {\n    /**\n     * @notice Underlying asset for this VToken\n     */\n    function underlying() external view returns (address);\n}\n"
    },
    "contracts/ResilientOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n// SPDX-FileCopyrightText: 2022 Venus\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/VBep20Interface.sol\";\nimport \"./interfaces/OracleInterface.sol\";\nimport \"./accessControl/AccessControlledV8.sol\";\n\n/**\n * @title ResilientOracle\n * @author Venus\n * @notice The Resilient Oracle is the main contract that the protocol uses to fetch prices of assets.\n *\n * DeFi protocols are vulnerable to price oracle failures including oracle manipulation and incorrectly\n * reported prices. If only one oracle is used, this creates a single point of failure and opens a vector\n * for attacking the protocol.\n *\n * The Resilient Oracle uses multiple sources and fallback mechanisms to provide accurate prices and protect\n * the protocol from oracle attacks. Currently it includes integrations with Chainlink, Pyth, Binance Oracle\n * and TWAP (Time-Weighted Average Price) oracles. TWAP uses PancakeSwap as the on-chain price source.\n *\n * For every market (vToken) we configure the main, pivot and fallback oracles. The oracles are configured per\n * vToken's underlying asset address. The main oracle oracle is the most trustworthy price source, the pivot\n * oracle is used as a loose sanity checker and the fallback oracle is used as a backup price source.\n *\n * To validate prices returned from two oracles, we use an upper and lower bound ratio that is set for every\n * market. The upper bound ratio represents the deviation between reported price (the price that’s being\n * validated) and the anchor price (the price we are validating against) above which the reported price will\n * be invalidated. The lower bound ratio presents the deviation between reported price and anchor price below\n * which the reported price will be invalidated. So for oracle price to be considered valid the below statement\n * should be true:\n\n```\nanchorRatio = anchorPrice/reporterPrice\nisValid = anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio\n```\n\n * In most cases, Chainlink is used as the main oracle, TWAP or Pyth oracles are used as the pivot oracle depending\n * on which supports the given market and Binance oracle is used as the fallback oracle. For some markets we may\n * use Pyth or TWAP as the main oracle if the token price is not supported by Chainlink or Binance oracles.\n *\n * For a fetched price to be valid it must be positive and not stagnant. If the price is invalid then we consider the\n * oracle to be stagnant and treat it like it's disabled.\n */\ncontract ResilientOracle is Pausable, AccessControlledV8, ResilientOracleInterface {\n    /**\n     * @dev Oracle roles:\n     * **main**: The most trustworthy price source\n     * **pivot**: Price oracle used as a loose sanity checker\n     * **fallback**: The backup source when main oracle price is invalidated\n     */\n    enum OracleRole {\n        MAIN,\n        PIVOT,\n        FALLBACK\n    }\n\n    struct TokenConfig {\n        /// @notice asset address\n        address asset;\n        /// @notice `oracles` stores the oracles based on their role in the following order:\n        /// [main, pivot, fallback],\n        /// It can be indexed with the corresponding enum OracleRole value\n        address[3] oracles;\n        /// @notice `enableFlagsForOracles` stores the enabled state\n        /// for each oracle in the same order as `oracles`\n        bool[3] enableFlagsForOracles;\n    }\n\n    uint256 public constant INVALID_PRICE = 0;\n\n    /// @notice deprecated, keep it here just to maintain the storage layout\n    /// @notice Native market address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable nativeMarket;\n\n    /// @notice deprecated, keeip it here just to maintain the storage layout\n    /// @notice VAI address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vai;\n\n    /// @notice Set this as asset address for Native token on each chain.\n    address public immutable nativeAsset;\n\n    /// @notice Bound validator contract address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    BoundValidatorInterface public immutable boundValidator;\n\n    mapping(address => TokenConfig) private tokenConfigs;\n\n    event TokenConfigAdded(\n        address indexed asset,\n        address indexed mainOracle,\n        address indexed pivotOracle,\n        address fallbackOracle\n    );\n\n    /// Event emitted when an oracle is set\n    event OracleSet(address indexed asset, address indexed oracle, uint256 indexed role);\n\n    /// Event emitted when an oracle is enabled or disabled\n    event OracleEnabled(address indexed asset, uint256 indexed role, bool indexed enable);\n\n    /**\n     * @notice Checks whether an address is null or not\n     */\n    modifier notNullAddress(address someone) {\n        if (someone == address(0)) revert(\"can't be zero address\");\n        _;\n    }\n\n    /**\n     * @notice Checks whether token config exists by checking whether asset is null address\n     * @dev address can't be null, so it's suitable to be used to check the validity of the config\n     * @param asset asset address\n     */\n    modifier checkTokenConfigExistence(address asset) {\n        if (tokenConfigs[asset].asset == address(0)) revert(\"token config must exist\");\n        _;\n    }\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @dev nativeMarketAddress can be address(0) if on the chain we do not support native market\n    ///      (e.g vETH on ethereum would not be supported, only vWETH)\n    /// @param nativeAssetAddress The address of a native asset (for ethereum it would be WETH address)\n    /// @param _boundValidator Address of the bound validator contract\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address nativeMarketAddress,\n        address nativeAssetAddress,\n        BoundValidatorInterface _boundValidator,\n        address accessControlManager_\n    ) notNullAddress(address(_boundValidator)) {\n        nativeMarket = nativeMarketAddress;\n        nativeAsset = nativeAssetAddress;\n        vai = 0x0000000000000000000000000000000000000000;\n        boundValidator = _boundValidator;\n\n        _setAccessControlManager(accessControlManager_);\n    }\n\n    /**\n     * @notice Pauses oracle\n     * @custom:access Only Governance\n     */\n    function pause() external {\n        _checkAccessAllowed(\"pause()\");\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses oracle\n     * @custom:access Only Governance\n     */\n    function unpause() external {\n        _checkAccessAllowed(\"unpause()\");\n        _unpause();\n    }\n\n    /**\n     * @notice Batch sets token configs\n     * @param tokenConfigs_ Token config array\n     * @custom:access Only Governance\n     * @custom:error Throws a length error if the length of the token configs array is 0\n     */\n    function setTokenConfigs(TokenConfig[] memory tokenConfigs_) external {\n        if (tokenConfigs_.length == 0) revert(\"length can't be 0\");\n        uint256 numTokenConfigs = tokenConfigs_.length;\n        for (uint256 i; i < numTokenConfigs; ) {\n            setTokenConfig(tokenConfigs_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Sets oracle for a given asset and role.\n     * @dev Supplied asset **must** exist and main oracle may not be null\n     * @param asset Asset address\n     * @param oracle Oracle address\n     * @param role Oracle role\n     * @custom:access Only Governance\n     * @custom:error Null address error if main-role oracle address is null\n     * @custom:error NotNullAddress error is thrown if asset address is null\n     * @custom:error TokenConfigExistance error is thrown if token config is not set\n     * @custom:event Emits OracleSet event with asset address, oracle address and role of the oracle for the asset\n     */\n    function setOracle(\n        address asset,\n        address oracle,\n        OracleRole role\n    ) external notNullAddress(asset) checkTokenConfigExistence(asset) {\n        _checkAccessAllowed(\"setOracle(address,address,uint8)\");\n        if (oracle == address(0) && role == OracleRole.MAIN) revert(\"can't set zero address to main oracle\");\n        tokenConfigs[asset].oracles[uint256(role)] = oracle;\n        emit OracleSet(asset, oracle, uint256(role));\n    }\n\n    /**\n     * @notice Enables/ disables oracle for the input asset. Token config for the input asset **must** exist\n     * @dev Configuration for the asset **must** already exist and the asset cannot be 0 address\n     * @param asset Asset address\n     * @param role Oracle role\n     * @param enable Enabled boolean of the oracle\n     * @custom:access Only Governance\n     * @custom:error NotNullAddress error is thrown if asset address is null\n     * @custom:error TokenConfigExistance error is thrown if token config is not set\n     */\n    function enableOracle(\n        address asset,\n        OracleRole role,\n        bool enable\n    ) external notNullAddress(asset) checkTokenConfigExistence(asset) {\n        _checkAccessAllowed(\"enableOracle(address,uint8,bool)\");\n        tokenConfigs[asset].enableFlagsForOracles[uint256(role)] = enable;\n        emit OracleEnabled(asset, uint256(role), enable);\n    }\n\n    /**\n     * @notice Updates the TWAP pivot oracle price.\n     * @dev This function should always be called before calling getUnderlyingPrice\n     * @param vToken vToken address\n     */\n    function updatePrice(address vToken) external override {\n        address asset = _getUnderlyingAsset(vToken);\n        (address pivotOracle, bool pivotOracleEnabled) = getOracle(asset, OracleRole.PIVOT);\n        if (pivotOracle != address(0) && pivotOracleEnabled) {\n            //if pivot oracle is not TwapOracle it will revert so we need to catch the revert\n            try TwapInterface(pivotOracle).updateTwap(asset) {} catch {}\n        }\n    }\n\n    /**\n     * @notice Updates the pivot oracle price. Currently using TWAP\n     * @dev This function should always be called before calling getPrice\n     * @param asset asset address\n     */\n    function updateAssetPrice(address asset) external {\n        (address pivotOracle, bool pivotOracleEnabled) = getOracle(asset, OracleRole.PIVOT);\n        if (pivotOracle != address(0) && pivotOracleEnabled) {\n            //if pivot oracle is not TwapOracle it will revert so we need to catch the revert\n            try TwapInterface(pivotOracle).updateTwap(asset) {} catch {}\n        }\n    }\n\n    /**\n     * @dev Gets token config by asset address\n     * @param asset asset address\n     * @return tokenConfig Config for the asset\n     */\n    function getTokenConfig(address asset) external view returns (TokenConfig memory) {\n        return tokenConfigs[asset];\n    }\n\n    /**\n     * @notice Gets price of the underlying asset for a given vToken. Validation flow:\n     * - Check if the oracle is paused globally\n     * - Validate price from main oracle against pivot oracle\n     * - Validate price from fallback oracle against pivot oracle if the first validation failed\n     * - Validate price from main oracle against fallback oracle if the second validation failed\n     * In the case that the pivot oracle is not available but main price is available and validation is successful,\n     * main oracle price is returned.\n     * @param vToken vToken address\n     * @return price USD price in scaled decimal places.\n     * @custom:error Paused error is thrown when resilent oracle is paused\n     * @custom:error Invalid resilient oracle price error is thrown if fetched prices from oracle is invalid\n     */\n    function getUnderlyingPrice(address vToken) public view override returns (uint256) {\n        if (paused()) revert(\"resilient oracle is paused\");\n\n        address asset = _getUnderlyingAsset(vToken);\n        return _getPrice(asset);\n    }\n\n    /**\n     * @notice Gets price of the asset\n     * @param asset asset address\n     * @return price USD price in scaled decimal places.\n     * @custom:error Paused error is thrown when resilent oracle is paused\n     * @custom:error Invalid resilient oracle price error is thrown if fetched prices from oracle is invalid\n     */\n    function getPrice(address asset) external view override returns (uint256) {\n        if (paused()) revert(\"resilient oracle is paused\");\n        return _getPrice(asset);\n    }\n\n    /**\n     * @notice Sets/resets single token configs.\n     * @dev main oracle **must not** be a null address\n     * @param tokenConfig Token config struct\n     * @custom:access Only Governance\n     * @custom:error NotNullAddress is thrown if asset address is null\n     * @custom:error NotNullAddress is thrown if main-role oracle address for asset is null\n     * @custom:event Emits TokenConfigAdded event when the asset config is set successfully by the authorized account\n     */\n    function setTokenConfig(\n        TokenConfig memory tokenConfig\n    ) public notNullAddress(tokenConfig.asset) notNullAddress(tokenConfig.oracles[uint256(OracleRole.MAIN)]) {\n        _checkAccessAllowed(\"setTokenConfig(TokenConfig)\");\n\n        tokenConfigs[tokenConfig.asset] = tokenConfig;\n        emit TokenConfigAdded(\n            tokenConfig.asset,\n            tokenConfig.oracles[uint256(OracleRole.MAIN)],\n            tokenConfig.oracles[uint256(OracleRole.PIVOT)],\n            tokenConfig.oracles[uint256(OracleRole.FALLBACK)]\n        );\n    }\n\n    /**\n     * @notice Gets oracle and enabled status by asset address\n     * @param asset asset address\n     * @param role Oracle role\n     * @return oracle Oracle address based on role\n     * @return enabled Enabled flag of the oracle based on token config\n     */\n    function getOracle(address asset, OracleRole role) public view returns (address oracle, bool enabled) {\n        oracle = tokenConfigs[asset].oracles[uint256(role)];\n        enabled = tokenConfigs[asset].enableFlagsForOracles[uint256(role)];\n    }\n\n    function _getPrice(address asset) internal view returns (uint256) {\n        uint256 pivotPrice = INVALID_PRICE;\n\n        // Get pivot oracle price, Invalid price if not available or error\n        (address pivotOracle, bool pivotOracleEnabled) = getOracle(asset, OracleRole.PIVOT);\n        if (pivotOracleEnabled && pivotOracle != address(0)) {\n            try OracleInterface(pivotOracle).getPrice(asset) returns (uint256 pricePivot) {\n                pivotPrice = pricePivot;\n            } catch {}\n        }\n\n        // Compare main price and pivot price, return main price and if validation was successful\n        // note: In case pivot oracle is not available but main price is available and\n        // validation is successful, the main oracle price is returned.\n        (uint256 mainPrice, bool validatedPivotMain) = _getMainOraclePrice(\n            asset,\n            pivotPrice,\n            pivotOracleEnabled && pivotOracle != address(0)\n        );\n        if (mainPrice != INVALID_PRICE && validatedPivotMain) return mainPrice;\n\n        // Compare fallback and pivot if main oracle comparision fails with pivot\n        // Return fallback price when fallback price is validated successfully with pivot oracle\n        (uint256 fallbackPrice, bool validatedPivotFallback) = _getFallbackOraclePrice(asset, pivotPrice);\n        if (fallbackPrice != INVALID_PRICE && validatedPivotFallback) return fallbackPrice;\n\n        // Lastly compare main price and fallback price\n        if (\n            mainPrice != INVALID_PRICE &&\n            fallbackPrice != INVALID_PRICE &&\n            boundValidator.validatePriceWithAnchorPrice(asset, mainPrice, fallbackPrice)\n        ) {\n            return mainPrice;\n        }\n\n        revert(\"invalid resilient oracle price\");\n    }\n\n    function getUnderlyingPrices(address[] memory cTokens) public view returns (uint256[] memory) {\n        uint256 length = cTokens.length;\n        uint256[] memory results = new uint256[](length);\n        for (uint256 i; i < length; ++i) {\n            results[i] = getUnderlyingPrice(cTokens[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @notice Gets a price for the provided asset\n     * @dev This function won't revert when price is 0, because the fallback oracle may still be\n     * able to fetch a correct price\n     * @param asset asset address\n     * @param pivotPrice Pivot oracle price\n     * @param pivotEnabled If pivot oracle is not empty and enabled\n     * @return price USD price in scaled decimals\n     * e.g. asset decimals is 8 then price is returned as 10**18 * 10**(18-8) = 10**28 decimals\n     * @return pivotValidated Boolean representing if the validation of main oracle price\n     * and pivot oracle price were successful\n     * @custom:error Invalid price error is thrown if main oracle fails to fetch price of the asset\n     * @custom:error Invalid price error is thrown if main oracle is not enabled or main oracle\n     * address is null\n     */\n    function _getMainOraclePrice(\n        address asset,\n        uint256 pivotPrice,\n        bool pivotEnabled\n    ) internal view returns (uint256, bool) {\n        (address mainOracle, bool mainOracleEnabled) = getOracle(asset, OracleRole.MAIN);\n        if (mainOracleEnabled && mainOracle != address(0)) {\n            try OracleInterface(mainOracle).getPrice(asset) returns (uint256 mainOraclePrice) {\n                if (!pivotEnabled) {\n                    return (mainOraclePrice, true);\n                }\n                if (pivotPrice == INVALID_PRICE) {\n                    return (mainOraclePrice, false);\n                }\n                return (\n                    mainOraclePrice,\n                    boundValidator.validatePriceWithAnchorPrice(asset, mainOraclePrice, pivotPrice)\n                );\n            } catch {\n                return (INVALID_PRICE, false);\n            }\n        }\n\n        return (INVALID_PRICE, false);\n    }\n\n    /**\n     * @dev This function won't revert when the price is 0 because getPrice checks if price is > 0\n     * @param asset asset address\n     * @return price USD price in 18 decimals\n     * @return pivotValidated Boolean representing if the validation of fallback oracle price\n     * and pivot oracle price were successfull\n     * @custom:error Invalid price error is thrown if fallback oracle fails to fetch price of the asset\n     * @custom:error Invalid price error is thrown if fallback oracle is not enabled or fallback oracle\n     * address is null\n     */\n    function _getFallbackOraclePrice(address asset, uint256 pivotPrice) private view returns (uint256, bool) {\n        (address fallbackOracle, bool fallbackEnabled) = getOracle(asset, OracleRole.FALLBACK);\n        if (fallbackEnabled && fallbackOracle != address(0)) {\n            try OracleInterface(fallbackOracle).getPrice(asset) returns (uint256 fallbackOraclePrice) {\n                if (pivotPrice == INVALID_PRICE) {\n                    return (fallbackOraclePrice, false);\n                }\n                return (\n                    fallbackOraclePrice,\n                    boundValidator.validatePriceWithAnchorPrice(asset, fallbackOraclePrice, pivotPrice)\n                );\n            } catch {\n                return (INVALID_PRICE, false);\n            }\n        }\n\n        return (INVALID_PRICE, false);\n    }\n\n    /**\n     * @dev This function returns the underlying asset of a vToken\n     * @param vToken vToken address\n     * @return asset underlying asset address\n     */\n    function _getUnderlyingAsset(address vToken) private view notNullAddress(vToken) returns (address asset) {\n        if (vToken == nativeMarket) {\n            asset = nativeAsset;\n        } else {\n            asset = VBep20Interface(vToken).underlying();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}